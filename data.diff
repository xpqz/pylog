diff --git a/docs/STAGE_2_PLAN.md b/docs/STAGE_2_PLAN.md
new file mode 100644
index 0000000..19bf756
--- /dev/null
+++ b/docs/STAGE_2_PLAN.md
@@ -0,0 +1,446 @@
+# Stage 2: Indexing Implementation Plan
+
+*First-argument indexing and type switching for performance optimization without semantic changes.*
+
+---
+
+## Overview
+
+Stage 2 introduces indexing optimizations to improve clause selection performance. The implementation uses first-argument indexing (principal functor → clause bucket) and type switching to reduce unnecessary unification attempts.
+
+## Goals
+
+1. **Significant performance improvement** for predicate lookups
+2. **No semantic changes** - identical solutions and ordering
+3. **Transparent integration** - no changes to existing tests
+4. **Measurable speedup** on standard benchmarks
+
+## Architecture
+
+### Core Components
+
+#### 1. IndexedProgram
+- Replaces flat clause list with indexed structure
+- Maps `(predicate_name, arity)` → PredIndex
+- Each predicate has its own index structure
+
+#### 2. Per-Predicate Index Structure
+```python
+class PredIndex:
+    """Index for a single predicate's clauses."""
+    def __init__(self):
+        # Source order of clause IDs for this predicate
+        self.order: List[int] = []
+        # Buckets for first-argument types
+        self.var_ids: Set[int] = set()              # Heads with variable first arg
+        self.empty_list_ids: Set[int] = set()       # Heads with []
+        self.int_ids: Set[int] = set()              # Heads with integer first arg
+        self.list_nonempty_ids: Set[int] = set()    # Heads with [H|T] i.e. '.'/2
+        self.struct_functor: Dict[Tuple[str,int], Set[int]] = {}  # Heads with f/n
+
+class ClauseIndex:
+    """Global index mapping predicates to their clause indices."""
+    def __init__(self):
+        # Map from (pred_name, pred_arity) to PredIndex
+        self.preds: Dict[Tuple[str,int], PredIndex] = {}
+        # Map from (pred_key, clause_id) to actual Clause
+        self.clauses: Dict[Tuple[Tuple[str,int], int], Clause] = {}
+```
+
+#### 3. First-Argument Analysis
+- Extract principal functor from clause heads
+- Handle special cases **per predicate**:
+  - Variables → var_ids bucket (match everything)
+  - Atoms (except `[]`) → struct_functor `(name, 0)` bucket
+  - Empty list `[]` → empty_list_ids bucket
+  - Non-empty lists `[H|T]` → list_nonempty_ids bucket  
+  - Integers → int_ids bucket
+  - Structures → struct_functor `(functor, arity)` bucket
+
+### Integration Points
+
+#### Engine Modifications
+```python
+# In Engine.__init__
+self.program = IndexedProgram(clauses) if use_indexing else Program(clauses)
+
+# In Engine.get_matching_clauses(goal)
+pred_key = (goal.functor, len(goal.args)) if is_struct(goal) else (goal, 0)
+if isinstance(self.program, IndexedProgram):
+    return self.program.select(pred_key, goal)
+else:
+    # Fallback: filter by predicate from flat list
+    return [c for c in self.program.clauses if matches_predicate(c, pred_key)]
+```
+
+#### Clause Selection Algorithm
+```python
+def select(self, pred_key: Tuple[str, int], goal) -> Iterable[Clause]:
+    """Select clauses preserving source order."""
+    if pred_key not in self.preds:
+        return []
+    
+    p = self.preds[pred_key]
+    
+    # 1. Dereference goal's first argument
+    first_arg = deref(goal.args[0]) if goal.args else None
+    
+    # 2. Build candidate set based on first arg type
+    candidates: Set[int] = set()
+    
+    if is_var(first_arg):
+        candidates = set(p.order)  # All clauses
+    elif is_atom(first_arg) and first_arg.name != '[]':
+        candidates |= p.var_ids
+        candidates |= p.struct_functor.get((first_arg.name, 0), set())
+    elif is_atom(first_arg) and first_arg.name == '[]':
+        candidates |= p.var_ids
+        candidates |= p.empty_list_ids
+    elif is_int(first_arg):
+        candidates |= p.var_ids
+        candidates |= p.int_ids
+    elif is_list_nonempty(first_arg):  # [H|T] structure
+        candidates |= p.var_ids
+        candidates |= p.list_nonempty_ids
+    elif is_struct(first_arg):
+        candidates |= p.var_ids
+        key = (first_arg.functor, len(first_arg.args))
+        candidates |= p.struct_functor.get(key, set())
+    
+    # 3. Yield clauses in original source order
+    for clause_id in p.order:
+        if clause_id in candidates:
+            yield self.clauses[(pred_key, clause_id)]
+```
+
+## Implementation Phases
+
+### Phase 1: Basic Infrastructure
+**Goal:** Set up indexing data structures
+
+**Tasks:**
+- [ ] Create `prolog/engine/indexing.py`
+- [ ] Implement `ClauseIndex` class
+- [ ] Add `IndexedProgram` wrapper
+- [ ] Write unit tests for index building
+
+**Tests:**
+```python
+def test_per_predicate_index_building():
+    """Ensure clauses are indexed per predicate, not globally."""
+    clauses = parse_program("""
+        foo(a).
+        foo(b).
+        foo(X) :- bar(X).
+        baz(1).
+        baz(X).
+    """)
+    index = ClauseIndex(clauses)
+    
+    # foo/1 should have its own index
+    foo_idx = index.preds[('foo', 1)]
+    assert len(foo_idx.order) == 3  # Three foo clauses
+    assert len(foo_idx.var_ids) == 1  # One with var head
+    
+    # baz/1 should be separate
+    baz_idx = index.preds[('baz', 1)]
+    assert len(baz_idx.order) == 2
+    assert len(baz_idx.int_ids) == 1
+    assert len(baz_idx.var_ids) == 1
+```
+
+### Phase 2: First-Argument Indexing
+**Goal:** Implement functor-based indexing
+
+**Tasks:**
+- [ ] Implement first-argument extraction
+- [ ] Build functor → clause mapping
+- [ ] Handle special cases (vars, lists)
+- [ ] Integrate with engine's clause selection
+
+**Tests:**
+```python
+def test_functor_indexing():
+    """Verify correct clause selection by functor."""
+    program = """
+        p(a, 1).
+        p(b, 2).
+        q(c, 3).
+    """
+    # Query p(a, X) should only try first two clauses
+```
+
+### Phase 3: Type Switching
+**Goal:** Add type-based pre-filtering
+
+**Tasks:**
+- [ ] Implement type detection for first argument
+- [ ] Build type → clause mapping
+- [ ] Combine with functor indexing
+- [ ] Optimize var bucket handling
+
+**Tests:**
+```python
+def test_type_switching():
+    """Verify type-based clause filtering."""
+    program = """
+        process(1) :- !.
+        process([H|T]) :- process(T).
+        process(foo(X)) :- process(X).
+    """
+    # Query with integer should only try first clause
+```
+
+### Phase 4: Performance Validation
+**Goal:** Verify measurable speedup
+
+**Tasks:**
+- [ ] Create benchmark suite
+- [ ] Measure clause selection overhead
+- [ ] Compare indexed vs linear performance
+- [ ] Document performance gains
+
+**Benchmarks:**
+```python
+# Benchmark 1: Large fact base
+# 1000 facts of form fact(atom_i, data)
+# Query: fact(atom_500, X)
+# Expected: ~500x speedup
+
+# Benchmark 2: Type dispatch
+# Multiple clauses with different first-arg types
+# Query: Mixed type queries
+# Expected: 3-5x speedup
+
+# Benchmark 3: Recursive predicates
+# append/3, member/2 with large lists
+# Expected: 2-3x speedup
+```
+
+## Testing Strategy
+
+### Critical Correctness Tests
+
+#### 1. Order Preservation with Interleaved Var Heads
+```python
+def test_order_preservation_with_var_heads():
+    """Variable heads must not disrupt source order."""
+    program = """
+        p(a).           % 1
+        p(X) :- b(X).   % 2 (var head)
+        p(b).           % 3
+    """
+    # Query p(a) must try #1 then #2 (not skip to #3)
+    # Query p(b) must try #2 then #3 (not #1)
+```
+
+#### 2. Empty List vs Non-Empty List Separation  
+```python
+def test_list_type_separation():
+    """[] and [H|T] require separate buckets."""
+    program = """
+        q([]).          % Only for empty list
+        q([_|_]).       % Only for non-empty list
+        q(X).           % For any list
+    """
+    # q([]) tries #1 and #3, never #2
+    # q([1]) tries #2 and #3, never #1
+```
+
+#### 3. Struct Functor Discrimination
+```python
+def test_struct_functor_filtering():
+    """Different functors must use different buckets."""
+    program = """
+        r(f(_)).
+        r(g(_)).
+        r(_).
+    """
+    # r(f(1)) tries r(f(_)) then r(_), never g(_)
+```
+
+#### 4. Dereferencing Critical
+```python
+def test_deref_before_selection():
+    """Selection must use dereferenced first argument."""
+    program = """
+        s(a) :- !.
+        s(b).
+        test(Y) :- Y = a, s(Y).
+    """
+    # When s(Y) is called with Y bound to 'a',
+    # must select s(a) clause, not all s/1 clauses
+```
+
+#### 5. Predicate Isolation
+```python
+def test_predicate_isolation():
+    """Different predicates never share buckets."""
+    program = """
+        p(a).
+        q(a).
+    """
+    # Selecting for p/1 must never return q/1 clauses
+```
+
+### Unit Tests
+- Index building correctness
+- Per-predicate bucket organization
+- Type detection accuracy
+- Edge cases (empty programs, single clause)
+
+### Integration Tests
+- All Stage 1 tests must pass unchanged
+- Solution order preservation
+- Backtracking behavior identical
+- Cut semantics preserved
+
+### Performance Tests
+```python
+@pytest.mark.benchmark
+def test_indexing_speedup():
+    """Verify indexing provides measurable speedup."""
+    # Generate 1000 facts
+    facts = [f"fact(a{i}, {i})." for i in range(1000)]
+    program = parse_program("\n".join(facts))
+    
+    # Time with indexing
+    indexed_engine = Engine(program, use_indexing=True)
+    indexed_time = time_query(indexed_engine, "fact(a500, X)")
+    
+    # Time without indexing
+    linear_engine = Engine(program, use_indexing=False)
+    linear_time = time_query(linear_engine, "fact(a500, X)")
+    
+    # Expect significant speedup (30x-300x range)
+    speedup_ratio = linear_time / indexed_time
+    assert speedup_ratio >= 30, f"Insufficient speedup: {speedup_ratio:.1f}x"
+    
+def test_small_predicate_no_regression():
+    """Small predicates should not regress."""
+    program = """
+        tiny(a).
+        tiny(b).
+        tiny(c).
+    """
+    # Performance should be within ±20% of linear scan
+```
+
+### Property Tests
+```python
+@given(program=prolog_programs(), query=prolog_queries())
+def test_indexing_preserves_semantics(program, query):
+    """Indexing must not change solutions or ordering."""
+    indexed = Engine(program, use_indexing=True)
+    linear = Engine(program, use_indexing=False)
+    
+    indexed_solutions = list(indexed.run(query))
+    linear_solutions = list(linear.run(query))
+    
+    assert indexed_solutions == linear_solutions
+```
+
+## Success Criteria
+
+### Functional
+- ✅ All Stage 1 and 1.5 tests pass unchanged
+- ✅ Solution order identical to linear scan
+- ✅ Backtracking behavior preserved
+- ✅ No semantic changes
+
+### Performance
+- ✅ 30x-300x speedup for large fact bases (mid-table queries)
+- ✅ 3-5x speedup for type dispatch scenarios
+- ✅ 2-3x speedup for typical recursive predicates
+- ✅ No regression (within ±20%) for small predicates (≤3 clauses)
+
+### Code Quality
+- ✅ Clean separation of concerns (indexing module)
+- ✅ Backward compatible (indexing optional)
+- ✅ Well-documented index structure
+- ✅ Comprehensive test coverage
+
+## Implementation Notes
+
+### Key Implementation Principle
+**Order ∩ Candidates Pattern**: The core correctness invariant is to filter candidates through source order, never concatenate buckets. This ensures identical solution ordering:
+```python
+# CORRECT: Filter through order
+for clause_id in p.order:
+    if clause_id in candidates:
+        yield clause
+
+# WRONG: Concatenate buckets (breaks ordering)
+yield from var_clauses + type_clauses + functor_clauses
+```
+
+### Design Decisions
+1. **Per-predicate indexing** - Each predicate has its own PredIndex to avoid cross-contamination
+2. **Source order preservation** - Critical for Prolog semantics
+3. **Variable clauses always checked** - Cannot be filtered out
+4. **Index built once** - At program load time
+5. **Dereference before selection** - Must use bound values for correct bucket selection
+6. **Separate [] and [H|T]** - Empty list is an atom, non-empty is '.'/2 structure
+
+### Optimization Opportunities
+- **Multi-argument indexing** (future stage)
+- **JIT index building** (build on first query)
+- **Argument type vectors** (beyond first arg)
+- **Trie-based indexing** (for deep structures)
+
+### Edge Cases
+- Programs with all variable heads
+- Single clause predicates (no benefit)
+- Deeply nested first arguments
+- Mixed indexable/non-indexable predicates
+
+## Rollout Plan
+
+### Week 1: Infrastructure
+- Set up indexing module
+- Implement basic data structures
+- Unit tests for index building
+
+### Week 2: Integration
+- Wire into engine
+- Implement clause selection
+- Ensure backward compatibility
+
+### Week 3: Optimization
+- Type switching
+- Performance tuning
+- Benchmark suite
+
+### Week 4: Validation
+- Full regression testing
+- Performance documentation
+- Code review and cleanup
+
+## Risks and Mitigations
+
+| Risk | Impact | Mitigation |
+|------|--------|------------|
+| Ordering changes | High | Extensive testing, property tests |
+| Memory overhead | Medium | Measure and document, make optional |
+| Complex edge cases | Medium | Comprehensive test suite |
+| Performance regression for small programs | Low | Threshold for enabling indexing |
+
+## Future Extensions (Not in Stage 2)
+
+- **Multi-argument indexing** - Index on multiple arguments
+- **Argument indexing** - Index on specific argument positions
+- **Deep indexing** - Index nested structures
+- **Dynamic indexing** - Update index for assert/retract
+- **Hash consing** - Share common subterms
+- **Mode declarations** - Optimize based on usage patterns
+
+## Acceptance Checklist
+
+- [ ] All Stage 1 tests pass
+- [ ] All Stage 1.5 tests pass
+- [ ] Performance benchmarks show improvement
+- [ ] Solution ordering unchanged
+- [ ] Backtracking behavior identical
+- [ ] Memory usage documented
+- [ ] Code review completed
+- [ ] Documentation updated
\ No newline at end of file
diff --git a/docs/TODO-2.md b/docs/TODO-2.md
new file mode 100644
index 0000000..db33aa9
--- /dev/null
+++ b/docs/TODO-2.md
@@ -0,0 +1,398 @@
+# TODO: Stage 2 (Indexing for Performance)
+
+## Phase 1: Basic Infrastructure
+
+### 1. Create Indexing Module
+- [ ] Create prolog/engine/indexing.py
+- [ ] Add module docstring explaining first-argument indexing
+- [ ] Import necessary dependencies (Terms, deref)
+- [ ] Set up module structure
+
+### 2. Implement Core Data Structures
+- [ ] Write test: ClauseIndex initializes empty
+- [ ] Write test: PredIndex stores clauses per predicate
+- [ ] Write test: Clause IDs maintain source order
+- [ ] Implement PredIndex class with buckets (var_ids, empty_list_ids, int_ids, list_nonempty_ids, struct_functor)
+- [ ] Implement ClauseIndex class with preds dict and clauses dict
+- [ ] Verify data structure initialization
+
+### 3. Index Building from Clauses
+- [ ] Write test: Index building preserves source order
+- [ ] Write test: Clauses indexed per predicate, not globally
+- [ ] Write test: Each predicate has separate PredIndex
+- [ ] Write test: Clause IDs are unique per predicate
+- [ ] Implement add_clause method
+- [ ] Implement build_from_clauses function
+- [ ] Verify index building correctness
+
+### 4. First-Argument Analysis
+- [ ] Write test: Extract principal functor from Atom
+- [ ] Write test: Extract principal functor from Struct
+- [ ] Write test: Detect variable first argument
+- [ ] Write test: Detect empty list [] as special atom
+- [ ] Write test: Detect non-empty list [H|T] as '.'/2 structure
+- [ ] Write test: Detect integer first argument (including negatives)
+- [ ] Write test: Clause IDs are monotonic per predicate in source order
+- [ ] Write test: build_from_clauses is deterministic given same input
+- [ ] Implement analyze_first_arg function
+- [ ] Map clause heads to appropriate buckets
+- [ ] Verify bucket assignment
+
+### 5. Static Program Assumption
+- [ ] Write test: Index assumes static program (no dynamic predicates)
+- [ ] Write test: Error/assertion if clauses added after index built
+- [ ] Document Stage 2 static program scope
+- [ ] Implement guard against post-build modifications
+- [ ] Add policy for rebuild vs assertion
+
+## Phase 2: First-Argument Indexing
+
+### 1. Bucket Organization
+- [ ] Write test: Variable heads go to var_ids bucket
+- [ ] Write test: Atom heads go to struct_functor[(name, 0)]
+- [ ] Write test: Atom('[]') goes to empty_list_ids, NOT struct_functor
+- [ ] Write test: Empty list [] goes to empty_list_ids
+- [ ] Write test: Non-empty list [H|T] goes to list_nonempty_ids
+- [ ] Write test: Integer heads go to int_ids (positive and negative)
+- [ ] Write test: p(-3) and p(3) both use int_ids bucket
+- [ ] Write test: Struct heads go to struct_functor[(functor, arity)]
+- [ ] Write test: Float bucket placeholder (mark xfail for future)
+- [ ] Add __slots__ to PredIndex for memory efficiency
+- [ ] Implement bucket assignment logic
+- [ ] Verify all clause types categorized correctly
+
+### 2. Clause Selection Algorithm
+- [ ] Write test: Select clauses for atom goal
+- [ ] Write test: Select clauses for struct goal
+- [ ] Write test: Select clauses for variable goal (all clauses)
+- [ ] Write test: Select clauses for integer goal
+- [ ] Write test: Select clauses for empty list goal
+- [ ] Write test: Select clauses for non-empty list goal
+- [ ] Implement select method in ClauseIndex
+- [ ] Build candidate set based on dereferenced first arg
+- [ ] Verify selection correctness
+
+### 3. Order Preservation (Critical)
+- [ ] Write test: Order preservation with interleaved var heads
+- [ ] Write test: Source order maintained within candidates
+- [ ] Write test: Never concatenate buckets (filter through order)
+- [ ] Write test: Variable clauses always included when matching
+- [ ] Implement order ∩ candidates pattern
+- [ ] Verify identical solution ordering
+
+### 4. Dereferencing Before Selection
+- [ ] Write test: Selection uses dereferenced first argument
+- [ ] Write test: Bound variables select correct bucket
+- [ ] Write test: Unbound variables select all clauses
+- [ ] Write test: Deref of attributed variable treated as variable
+- [ ] Write test: Attributed vars select all clauses (not struct bucket)
+- [ ] Integrate deref into selection logic
+- [ ] Verify runtime binding respected
+
+## Phase 2.5: Predicate Isolation & Small-Predicate Heuristic
+
+### 1. Predicate Isolation Guarantees
+- [ ] Write test: ClauseIndex never mixes predicates in single bucket
+- [ ] Write test: PredIndex objects only reachable via (name, arity) keys
+- [ ] Write property test: Two predicates with identical first-arg shapes don't share buckets
+- [ ] Write test: Selection for p/1 never returns q/1 clauses
+- [ ] Write test: Predicate key includes arity in both build and select
+- [ ] Implement strict predicate isolation
+- [ ] Verify no cross-contamination possible
+
+### 2. Small Predicate Optimization
+- [ ] Write test: Predicates with <= 3 clauses can bypass indexing
+- [ ] Write test: Bypass threshold is configurable
+- [ ] Write test: No performance regression for tiny predicates
+- [ ] Write test: Semantics identical with bypass active
+- [ ] Implement bypass heuristic
+- [ ] Document rationale and threshold
+
+## Phase 3: Type Switching
+
+### 1. Type Detection
+- [ ] Write test: Detect atom type (non-empty-list)
+- [ ] Write test: Detect empty list as special atom
+- [ ] Write test: Detect non-empty list type
+- [ ] Write test: Detect integer type
+- [ ] Write test: Detect struct type
+- [ ] Write test: Detect variable type
+- [ ] Implement type detection functions
+- [ ] Verify type discrimination
+
+### 2. List Type Separation
+- [ ] Write test: [] and [H|T] require separate buckets
+- [ ] Write test: [] never matches [H|T] clauses
+- [ ] Write test: [H|T] never matches [] clauses
+- [ ] Write test: Variable clauses match both list types
+- [ ] Verify list type separation
+
+### 3. Struct Functor Discrimination
+- [ ] Write test: Different functors use different buckets
+- [ ] Write test: Same functor different arity separate buckets
+- [ ] Write test: f/1 doesn't match g/1
+- [ ] Write test: f/1 doesn't match f/2
+- [ ] Verify functor/arity discrimination
+
+### 4. Predicate Isolation
+- [ ] Write test: Different predicates never share buckets
+- [ ] Write test: p/1 clauses never returned for q/1 query
+- [ ] Write test: Predicate key includes arity
+- [ ] Verify complete predicate isolation
+
+## Phase 4: Engine Integration
+
+### 1. IndexedProgram Wrapper
+- [ ] Write test: IndexedProgram wraps ClauseIndex
+- [ ] Write test: Provides select method interface
+- [ ] Write test: Falls back gracefully if not available
+- [ ] Implement IndexedProgram class
+- [ ] Add use_indexing parameter support
+- [ ] Verify wrapper functionality
+
+### 2. Engine Modifications
+- [ ] Write test: Engine accepts use_indexing parameter
+- [ ] Write test: Engine creates IndexedProgram when enabled
+- [ ] Write test: Engine creates Program when disabled
+- [ ] Write test: get_matching_clauses uses indexing when available
+- [ ] Modify Engine.__init__ for indexing support
+- [ ] Modify get_matching_clauses to use program.select
+- [ ] Verify integration works
+
+### 3. Backward Compatibility
+- [ ] Write test: Engine works without indexing (default)
+- [ ] Write test: All Stage 1 tests pass with indexing disabled
+- [ ] Write test: All Stage 1.5 tests pass with indexing disabled
+- [ ] Write test: use_indexing=False behaves identically to Stage 1.5
+- [ ] Ensure no regressions without indexing
+- [ ] Verify complete backward compatibility
+
+### 4. Semantic Preservation
+- [ ] Write test: Solutions identical with/without indexing
+- [ ] Write test: Solution ordering unchanged
+- [ ] Write test: Backtracking behavior identical
+- [ ] Write test: Cut semantics preserved
+- [ ] Write property test: Random programs produce same results
+- [ ] Verify no semantic changes
+
+## Phase 4.5: Streaming & Debug Instrumentation
+
+### 1. Streaming Selection
+- [ ] Write test: select() returns iterator/generator, not list
+- [ ] Write test: Streaming behavior with cut - only first candidate visited
+- [ ] Write test: Memory profile stays constant with large candidate sets
+- [ ] Implement select() as generator
+- [ ] Verify lazy evaluation
+
+### 2. Debug Instrumentation
+- [ ] Write test: Debug counter tracks candidates considered
+- [ ] Write test: Counter resets between calls
+- [ ] Write test: Counter only increments for visited candidates
+- [ ] Implement debug counters (behind flag)
+- [ ] Add trace output: "pred p/1: considered K of N clauses"
+- [ ] Document instrumentation usage
+
+## Phase 5: Correctness Testing
+
+### 1. Critical Edge Cases
+- [ ] Write test: Programs with all variable heads
+- [ ] Write test: Single clause predicates
+- [ ] Write test: Predicates with no clauses
+- [ ] Write test: Deeply nested first arguments
+- [ ] Write test: Mixed indexable/non-indexable predicates
+- [ ] Verify edge case handling
+
+### 2. Order Preservation Tests
+- [ ] Write test: Variable heads don't disrupt order
+- [ ] Write test: Interleaved types maintain order
+- [ ] Write test: Complex ordering scenarios
+- [ ] Write test: Backtracking order unchanged
+- [ ] Verify strict order preservation
+
+### 3. Type Switching Tests
+- [ ] Write test: Integer vs atom discrimination
+- [ ] Write test: List vs struct discrimination
+- [ ] Write test: Empty vs non-empty list discrimination
+- [ ] Write test: All type combinations
+- [ ] Verify type switching correctness
+
+### 4. Integration Tests
+- [ ] Run all Stage 1 tests with indexing enabled
+- [ ] Run all Stage 1.5 tests with indexing enabled
+- [ ] Test complex programs (append, member, reverse)
+- [ ] Test recursive predicates
+- [ ] Verify no test regressions
+
+## Phase 5.5: Cut & Backtracking Regression Guard
+
+### 1. Cut Interaction Tests
+- [ ] Write test: Interleaved var/ground heads + cut preserves pruning
+- [ ] Write test: Cut in first matching clause behaves identically
+- [ ] Write test: Clause with cut followed by non-matching clauses
+- [ ] Write test: Cut doesn't affect indexing correctness
+- [ ] Verify cut semantics preservation
+
+### 2. Backtracking Edge Cases
+- [ ] Write test: Choicepoint creation identical with/without indexing
+- [ ] Write test: Trail operations identical
+- [ ] Write test: Failure-driven loops work correctly
+- [ ] Verify backtracking invariants
+
+## Phase 6: Performance Validation
+
+### 1. Benchmark Suite Creation
+- [ ] Create benchmark module in tests/benchmarks/
+- [ ] Write large fact base benchmark (1000+ facts)
+- [ ] Write type dispatch benchmark
+- [ ] Write recursive predicate benchmark
+- [ ] Write mixed workload benchmark
+- [ ] Set up timing infrastructure
+
+### 2. Performance Measurements
+- [ ] Write test: 30x-300x speedup for large fact bases
+- [ ] Write test: 3-5x speedup for type dispatch
+- [ ] Write test: 2-3x speedup for recursive predicates
+- [ ] Write test: No regression (±20%) for small predicates
+- [ ] Implement performance comparison
+- [ ] Document speedup ratios
+
+### 3. Memory Overhead Analysis
+- [ ] Write test: Compare sys.getsizeof with/without indexing
+- [ ] Write test: Memory overhead on 10k clause synthetic program
+- [ ] Measure index memory usage
+- [ ] Compare with flat clause list
+- [ ] Document memory overhead
+- [ ] Verify acceptable memory usage
+- [ ] Add memory usage to documentation
+
+### 4. Performance Documentation
+- [ ] Document benchmark results
+- [ ] Create performance comparison table
+- [ ] Add graphs showing speedup
+- [ ] Document when indexing helps most
+- [ ] Update README with performance notes
+
+## Phase 6.5: CI & Benchmark Hygiene
+
+### 1. Test Markers
+- [ ] Mark all performance tests with @pytest.mark.perf
+- [ ] Mark all benchmarks with @pytest.mark.benchmark
+- [ ] Configure pytest to exclude perf tests by default
+- [ ] Add separate CI job for performance tests
+- [ ] Document how to run performance tests
+
+### 2. Benchmark Stability
+- [ ] Implement warm-up runs before timing
+- [ ] Use median-of-3 or median-of-5 timing
+- [ ] Add variance/stability checks
+- [ ] Handle CI timing variability
+- [ ] Document benchmark methodology
+
+## Phase 7: Property Testing
+
+### 1. Semantic Equivalence Properties
+- [ ] Write property: Solutions identical with/without indexing
+- [ ] Write property: Solution ordering preserved
+- [ ] Write property: Backtracking points identical
+- [ ] Write property: Variable bindings identical
+- [ ] Implement property test generators
+- [ ] Run extensive property tests
+
+### 2. Index Correctness Properties
+- [ ] Write property: All matching clauses selected
+- [ ] Write property: No non-matching clauses selected
+- [ ] Write property: Order preserved within selection
+- [ ] Write property: Dereferencing handled correctly
+- [ ] Verify index correctness properties
+
+### 3. Performance Properties
+- [ ] Write property: Indexing never slower than 2x overhead
+- [ ] Write property: Large predicates show speedup
+- [ ] Write property: Memory overhead bounded
+- [ ] Verify performance properties
+
+## Phase 8: Documentation and Cleanup
+
+### 1. Code Documentation
+- [ ] Document ClauseIndex class and methods
+- [ ] Document PredIndex structure
+- [ ] Document IndexedProgram interface
+- [ ] Document engine integration points
+- [ ] Add inline comments for complex logic
+
+### 2. User Documentation
+- [ ] Update README with Stage 2 features
+- [ ] Document how to enable indexing
+- [ ] Document performance benefits
+- [ ] Add indexing examples
+- [ ] Create indexing guide
+
+### 3. Test Documentation
+- [ ] Document test strategy
+- [ ] Document critical test cases
+- [ ] Document performance benchmarks
+- [ ] Add test coverage report
+
+### 4. Code Cleanup
+- [ ] Remove debug prints
+- [ ] Optimize hot paths
+- [ ] Refactor for clarity
+- [ ] Run black formatter
+- [ ] Final code review
+
+## Phase 9: Final Validation
+
+### 1. Full Test Suite
+- [ ] Run all unit tests with indexing
+- [ ] Run all integration tests with indexing
+- [ ] Run all property tests
+- [ ] Run all benchmarks
+- [ ] Verify 100% pass rate
+
+### 2. Acceptance Criteria
+- [ ] ✓ All Stage 1 and 1.5 tests pass unchanged
+- [ ] ✓ Solution order identical to linear scan
+- [ ] ✓ Backtracking behavior preserved
+- [ ] ✓ No semantic changes
+- [ ] ✓ 30x-300x speedup for large fact bases
+- [ ] ✓ 3-5x speedup for type dispatch
+- [ ] ✓ 2-3x speedup for recursive predicates
+- [ ] ✓ No regression for small predicates
+- [ ] ✓ Clean separation of concerns
+- [ ] ✓ Backward compatible
+- [ ] ✓ Well-documented
+- [ ] ✓ Comprehensive test coverage
+
+### 3. Performance Report
+- [ ] Generate final benchmark results
+- [ ] Create performance comparison charts
+- [ ] Document speedup achieved
+- [ ] Identify future optimization opportunities
+- [ ] Publish performance report
+
+### 4. Stage 2 Completion
+- [ ] Create PR for Stage 2
+- [ ] Ensure CI passes
+- [ ] Code review completed
+- [ ] Merge to main
+- [ ] Update project status
+- [ ] Stage 2 complete
+
+## Notes
+- Order ∩ Candidates is the core correctness pattern - NEVER concatenate buckets
+- Always dereference before selection - bound values determine bucket
+- Per-predicate indexing prevents cross-contamination - enforced by design
+- Variable clauses must always be candidates - cannot be filtered out
+- Empty list is Atom('[]'), not a list structure - special bucket required
+- Non-empty list [H|T] is '.'/2 structure - separate from empty list
+- Source order must be preserved exactly - filter through order, not concatenate
+- Stage 2 assumes static program - no assert/retract support
+- Integers include negative values - p(-3) and p(3) both use int_ids
+- Attributed variables treated as unbound variables for selection
+- select() must return iterator/generator for streaming semantics
+- Small predicates (≤3 clauses) may bypass indexing for efficiency
+- Performance gain is the primary goal - 30x-300x for large fact bases
+- Indexing is optional (use_indexing parameter) - backward compatible
+- Debug instrumentation helps verify performance claims
+- Cut semantics must be preserved exactly
+- Memory overhead should be bounded and documented
\ No newline at end of file
diff --git a/prolog/engine/indexing.py b/prolog/engine/indexing.py
new file mode 100644
index 0000000..9c0f489
--- /dev/null
+++ b/prolog/engine/indexing.py
@@ -0,0 +1,212 @@
+"""
+Stage 2: First-argument indexing infrastructure for performance optimization.
+
+This module implements per-predicate indexing based on the principal functor
+of the first argument. It provides significant speedup for clause selection
+without changing Prolog semantics.
+
+Key invariants:
+- Source order is always preserved (Order ∩ Candidates pattern)
+- Per-predicate isolation (no cross-contamination)
+- Static program assumption (no dynamic predicates in Stage 2)
+"""
+
+from typing import Dict, List, Set, Tuple, Optional, Union, Iterator
+from prolog.ast.terms import Term, Atom, Int, Var, Struct, List as PrologList
+from prolog.unify.store import Store
+from prolog.ast.clauses import Clause
+
+
+class PredIndex:
+    """
+    Per-predicate index structure organizing clauses by first-argument type.
+    
+    Uses buckets to categorize clauses for efficient selection while
+    maintaining source order through the order list.
+    """
+    
+    __slots__ = (
+        'order',              # List[int]: clause IDs in source order
+        'var_ids',            # Set[int]: clauses with variable first arg
+        'empty_list_ids',     # Set[int]: clauses with [] first arg
+        'int_ids',            # Set[int]: clauses with integer first arg
+        'list_nonempty_ids',  # Set[int]: clauses with [H|T] first arg
+        'struct_functor',     # Dict[Tuple[str,int], Set[int]]: (functor, arity) -> clause IDs
+        'float_ids',          # Set[int]: placeholder for future float support
+    )
+    
+    def __init__(self):
+        """Initialize empty per-predicate index."""
+        self.order: List[int] = []
+        self.var_ids: Set[int] = set()
+        self.empty_list_ids: Set[int] = set()
+        self.int_ids: Set[int] = set()
+        self.list_nonempty_ids: Set[int] = set()
+        self.struct_functor: Dict[Tuple[str, int], Set[int]] = {}
+        self.float_ids: Set[int] = set()  # Future extension
+
+
+class ClauseIndex:
+    """
+    Global index mapping predicates to their clause indices.
+    
+    Maintains complete isolation between predicates and supports
+    efficient clause selection based on first-argument indexing.
+    """
+    
+    __slots__ = (
+        'preds',         # Dict[Tuple[str,int], PredIndex]: (name, arity) -> per-pred index
+        'clauses',       # Dict[Tuple[Tuple[str,int], int], Clause]: ((name, arity), id) -> clause
+        'finalized',     # bool: whether index is finalized (static program)
+        'supports_rebuild',  # bool: whether rebuilding is supported
+    )
+    
+    def __init__(self):
+        """Initialize empty global index."""
+        self.preds: Dict[Tuple[str, int], PredIndex] = {}
+        self.clauses: Dict[Tuple[Tuple[str, int], int], Clause] = {}
+        self.finalized: bool = False
+        self.supports_rebuild: bool = False  # Stage 2 assumes static programs
+    
+    def add_clause(self, clause: Clause) -> None:
+        """
+        Add a clause to the index.
+        
+        Raises AssertionError if index is finalized (static program assumption).
+        """
+        assert not self.finalized, "Cannot add clauses after index is built (static program assumption)"
+        # This will be called during build_from_clauses
+        raise NotImplementedError("Use build_from_clauses instead")
+
+
+def analyze_first_arg(head: Term, store: Store) -> Union[str, Tuple[str, str, int]]:
+    """
+    Analyze the first argument of a clause head to determine its type.
+    
+    Returns:
+        - "no_args" for zero-arity predicates
+        - "var" for variable first arguments
+        - "empty_list" for the empty list []
+        - "list_nonempty" for non-empty lists [H|T]
+        - "int" for integer first arguments
+        - ("atom", name, 0) for atoms (treated as 0-arity structures)
+        - ("struct", functor, arity) for compound structures
+    """
+    # Handle zero-arity predicates
+    if isinstance(head, Atom):
+        return "no_args"
+    
+    if not isinstance(head, Struct) or not head.args:
+        return "no_args"
+    
+    # Get and dereference the first argument
+    first_arg = head.args[0]
+    # Note: In actual implementation, we'd dereference if we had a store with bindings
+    # For index building, variables are unbound, so deref would return the variable itself
+    
+    # Check variable
+    if isinstance(first_arg, Var):
+        return "var"
+    
+    # Check integer (positive or negative)
+    if isinstance(first_arg, Int):
+        return "int"
+    
+    # Check empty list - both representations
+    if isinstance(first_arg, PrologList):
+        if len(first_arg.items) == 0:
+            return "empty_list"
+        else:
+            return "list_nonempty"
+    
+    # Check atom (including special [] atom)
+    if isinstance(first_arg, Atom):
+        if first_arg.name == "[]":
+            return "empty_list"
+        else:
+            # Atoms are keyed in struct_functor with arity 0
+            return ("atom", first_arg.name, 0)
+    
+    # Check struct
+    if isinstance(first_arg, Struct):
+        # Special case: canonical list representation '.'/2
+        if first_arg.functor == "." and len(first_arg.args) == 2:
+            return "list_nonempty"
+        else:
+            return ("struct", first_arg.functor, len(first_arg.args))
+    
+    # Should not reach here for well-formed Prolog terms
+    raise ValueError(f"Unknown term type for first-argument analysis: {type(first_arg)}")
+
+
+def build_from_clauses(clauses: List[Clause]) -> ClauseIndex:
+    """
+    Build a complete index from a list of clauses.
+    
+    Maintains source order and ensures per-predicate isolation.
+    The resulting index is finalized and assumes a static program.
+    """
+    idx = ClauseIndex()
+    store = Store()  # Empty store for analysis (no bindings during indexing)
+    
+    # Track clause IDs per predicate
+    pred_counters: Dict[Tuple[str, int], int] = {}
+    
+    for clause in clauses:
+        # Determine predicate key
+        head = clause.head
+        if isinstance(head, Atom):
+            pred_key = (head.name, 0)
+        elif isinstance(head, Struct):
+            pred_key = (head.functor, len(head.args))
+        else:
+            raise ValueError(f"Invalid clause head type: {type(head)}")
+        
+        # Ensure predicate has an index
+        if pred_key not in idx.preds:
+            idx.preds[pred_key] = PredIndex()
+            pred_counters[pred_key] = 0
+        
+        # Get clause ID for this predicate (monotonic, starts at 0)
+        clause_id = pred_counters[pred_key]
+        pred_counters[pred_key] += 1
+        
+        # Add to order list
+        pred_idx = idx.preds[pred_key]
+        pred_idx.order.append(clause_id)
+        
+        # Store clause in global mapping
+        idx.clauses[(pred_key, clause_id)] = clause
+        
+        # Analyze first argument and add to appropriate bucket
+        arg_type = analyze_first_arg(head, store)
+        
+        if arg_type == "no_args":
+            # Zero-arity predicates don't need bucketing
+            pass
+        elif arg_type == "var":
+            pred_idx.var_ids.add(clause_id)
+        elif arg_type == "empty_list":
+            pred_idx.empty_list_ids.add(clause_id)
+        elif arg_type == "list_nonempty":
+            pred_idx.list_nonempty_ids.add(clause_id)
+        elif arg_type == "int":
+            pred_idx.int_ids.add(clause_id)
+        elif isinstance(arg_type, tuple):
+            if arg_type[0] == "atom":
+                # Atoms go to struct_functor with arity 0
+                functor_key = (arg_type[1], arg_type[2])
+                if functor_key not in pred_idx.struct_functor:
+                    pred_idx.struct_functor[functor_key] = set()
+                pred_idx.struct_functor[functor_key].add(clause_id)
+            elif arg_type[0] == "struct":
+                # Structures go to struct_functor with their arity
+                functor_key = (arg_type[1], arg_type[2])
+                if functor_key not in pred_idx.struct_functor:
+                    pred_idx.struct_functor[functor_key] = set()
+                pred_idx.struct_functor[functor_key].add(clause_id)
+    
+    # Mark index as finalized
+    idx.finalized = True
+    
+    return idx
\ No newline at end of file
diff --git a/prolog/tests/unit/test_indexing.py b/prolog/tests/unit/test_indexing.py
new file mode 100644
index 0000000..2a747a0
--- /dev/null
+++ b/prolog/tests/unit/test_indexing.py
@@ -0,0 +1,458 @@
+"""
+Unit tests for Stage 2: Indexing infrastructure.
+
+Tests the core indexing data structures and algorithms for first-argument
+indexing with type switching.
+
+Note on list representations:
+- Empty lists can be represented as List((), Atom("[]")) or Atom('[]')
+- Non-empty lists can be List((head, ...), tail) or canonical Struct('.', (head, tail))
+- Stage 2 indexing must handle both representations correctly
+"""
+
+import pytest
+from prolog.ast.terms import Atom, Int, Var, Struct, List
+from prolog.unify.store import Store
+from prolog.ast.clauses import Clause
+from prolog.engine.indexing import (
+    PredIndex,
+    ClauseIndex,
+    build_from_clauses,
+    analyze_first_arg,
+)
+
+
+class TestPredIndex:
+    """Tests for per-predicate index structure."""
+
+    def test_predindex_initializes_empty(self):
+        """PredIndex should initialize with empty buckets."""
+        idx = PredIndex()
+        assert idx.order == []
+        assert idx.var_ids == set()
+        assert idx.empty_list_ids == set()
+        assert idx.int_ids == set()
+        assert idx.list_nonempty_ids == set()
+        assert idx.struct_functor == {}
+
+    def test_predindex_has_slots_for_memory_efficiency(self):
+        """PredIndex should use __slots__ to reduce memory overhead."""
+        idx = PredIndex()
+        assert hasattr(idx.__class__, "__slots__")
+        # Should not have __dict__ due to __slots__
+        with pytest.raises(AttributeError):
+            _ = idx.__dict__
+
+    def test_predindex_stores_clause_ids_per_bucket(self):
+        """PredIndex should correctly categorize clause IDs into buckets."""
+        idx = PredIndex()
+        
+        # Add some clause IDs to different buckets
+        idx.order = [0, 1, 2, 3, 4]
+        idx.var_ids.add(0)
+        idx.empty_list_ids.add(1)
+        idx.int_ids.add(2)
+        idx.list_nonempty_ids.add(3)
+        idx.struct_functor[("foo", 2)] = {4}
+        
+        assert 0 in idx.var_ids
+        assert 1 in idx.empty_list_ids
+        assert 2 in idx.int_ids
+        assert 3 in idx.list_nonempty_ids
+        assert 4 in idx.struct_functor[("foo", 2)]
+
+
+class TestClauseIndex:
+    """Tests for the global clause index structure."""
+
+    def test_clauseindex_initializes_empty(self):
+        """ClauseIndex should initialize with empty dictionaries."""
+        idx = ClauseIndex()
+        assert idx.preds == {}
+        assert idx.clauses == {}
+
+    def test_clauseindex_stores_clauses_per_predicate(self):
+        """ClauseIndex should maintain separate PredIndex per predicate."""
+        idx = ClauseIndex()
+        
+        # Create PredIndex for different predicates
+        idx.preds[("foo", 1)] = PredIndex()
+        idx.preds[("bar", 2)] = PredIndex()
+        
+        assert ("foo", 1) in idx.preds
+        assert ("bar", 2) in idx.preds
+        assert idx.preds[("foo", 1)] is not idx.preds[("bar", 2)]
+
+    def test_clauseindex_maps_predicate_and_id_to_clause(self):
+        """ClauseIndex should map (pred_key, clause_id) to actual Clause."""
+        idx = ClauseIndex()
+        
+        # Create a test clause
+        clause = Clause(
+            head=Struct("foo", (Atom("a"),)),
+            body=()
+        )
+        
+        pred_key = ("foo", 1)
+        clause_id = 0
+        idx.clauses[(pred_key, clause_id)] = clause
+        
+        assert idx.clauses[(pred_key, clause_id)] is clause
+
+
+class TestFirstArgumentAnalysis:
+    """Tests for analyzing first argument of clause heads."""
+
+    def test_analyze_variable_first_arg(self):
+        """analyze_first_arg should detect variable first argument."""
+        store = Store()
+        head = Struct("p", (Var(0, "X"),))
+        arg_type = analyze_first_arg(head, store)
+        assert arg_type == "var"
+
+    def test_analyze_atom_first_arg(self):
+        """analyze_first_arg should detect atom first argument."""
+        # Atoms are keyed in struct_functor with arity 0
+        store = Store()
+        head = Struct("p", (Atom("foo"),))
+        arg_type = analyze_first_arg(head, store)
+        assert arg_type == ("atom", "foo", 0)
+
+    def test_analyze_empty_list_first_arg(self):
+        """analyze_first_arg should detect empty list [] as special."""
+        store = Store()
+        head = Struct("p", (List((), Atom("[]")),))  # Empty list
+        arg_type = analyze_first_arg(head, store)
+        assert arg_type == "empty_list"
+
+    def test_analyze_nonempty_list_first_arg(self):
+        """analyze_first_arg should detect non-empty list [H|T]."""
+        store = Store()
+        head = Struct("p", (List((Atom("a"),), Var(0, "T")),))  # [a|T]
+        arg_type = analyze_first_arg(head, store)
+        assert arg_type == "list_nonempty"
+
+    def test_analyze_integer_first_arg(self):
+        """analyze_first_arg should detect integer first argument."""
+        store = Store()
+        head = Struct("p", (Int(42),))
+        arg_type = analyze_first_arg(head, store)
+        assert arg_type == "int"
+
+    def test_analyze_negative_integer_first_arg(self):
+        """analyze_first_arg should handle negative integers."""
+        store = Store()
+        head = Struct("p", (Int(-3),))
+        arg_type = analyze_first_arg(head, store)
+        assert arg_type == "int"
+
+    def test_analyze_struct_first_arg(self):
+        """analyze_first_arg should detect struct with functor/arity."""
+        store = Store()
+        head = Struct("p", (Struct("foo", (Atom("a"), Atom("b"))),))
+        arg_type = analyze_first_arg(head, store)
+        assert arg_type == ("struct", "foo", 2)
+
+    def test_analyze_zero_arity_predicate(self):
+        """analyze_first_arg should handle predicates with no arguments."""
+        store = Store()
+        head = Atom("p")  # p/0
+        arg_type = analyze_first_arg(head, store)
+        assert arg_type == "no_args"
+
+
+class TestIndexBuilding:
+    """Tests for building index from clauses."""
+
+    def test_build_preserves_source_order(self):
+        """Index building must preserve original clause order."""
+        clauses = [
+            Clause(head=Struct("p", (Atom("a"),)), body=()),
+            Clause(head=Struct("p", (Var(0, "X"),)), body=()),
+            Clause(head=Struct("p", (Atom("b"),)), body=()),
+        ]
+        
+        idx = build_from_clauses(clauses)
+        pred_idx = idx.preds[("p", 1)]
+        
+        # Order should be [0, 1, 2] - exact source order
+        assert pred_idx.order == [0, 1, 2]
+
+    def test_clauses_indexed_per_predicate(self):
+        """Each predicate should have its own separate index."""
+        clauses = [
+            Clause(head=Struct("p", (Atom("a"),)), body=()),
+            Clause(head=Struct("q", (Atom("a"),)), body=()),
+            Clause(head=Struct("p", (Atom("b"),)), body=()),
+        ]
+        
+        idx = build_from_clauses(clauses)
+        
+        assert ("p", 1) in idx.preds
+        assert ("q", 1) in idx.preds
+        assert len(idx.preds[("p", 1)].order) == 2  # p has 2 clauses
+        assert len(idx.preds[("q", 1)].order) == 1  # q has 1 clause
+
+    def test_each_predicate_has_separate_predindex(self):
+        """Each predicate must have its own PredIndex instance."""
+        clauses = [
+            Clause(head=Struct("p", (Atom("a"),)), body=()),
+            Clause(head=Struct("q", (Atom("a"),)), body=()),
+        ]
+        
+        idx = build_from_clauses(clauses)
+        
+        p_idx = idx.preds[("p", 1)]
+        q_idx = idx.preds[("q", 1)]
+        assert p_idx is not q_idx
+
+    def test_clause_ids_unique_per_predicate(self):
+        """Clause IDs should be unique within each predicate."""
+        clauses = [
+            Clause(head=Struct("p", (Atom("a"),)), body=()),
+            Clause(head=Struct("p", (Atom("b"),)), body=()),
+            Clause(head=Struct("q", (Atom("c"),)), body=()),
+            Clause(head=Struct("p", (Atom("d"),)), body=()),
+        ]
+        
+        idx = build_from_clauses(clauses)
+        
+        p_ids = idx.preds[("p", 1)].order
+        q_ids = idx.preds[("q", 1)].order
+        
+        # p should have IDs [0, 1, 2]
+        assert p_ids == [0, 1, 2]
+        # q should have ID [0] (its own numbering)
+        assert q_ids == [0]
+
+    def test_clause_ids_monotonic_in_source_order(self):
+        """Clause IDs should be monotonic increasing in source order."""
+        clauses = [
+            Clause(head=Struct("p", (Atom("a"),)), body=()),
+            Clause(head=Struct("p", (Var(0, "X"),)), body=()),
+            Clause(head=Struct("p", (Int(3),)), body=()),
+            Clause(head=Struct("p", (Atom("b"),)), body=()),
+        ]
+        
+        idx = build_from_clauses(clauses)
+        p_idx = idx.preds[("p", 1)]
+        
+        # IDs should be [0, 1, 2, 3] and monotonic
+        assert p_idx.order == [0, 1, 2, 3]
+        for i in range(len(p_idx.order) - 1):
+            assert p_idx.order[i] < p_idx.order[i + 1]
+
+    def test_build_from_clauses_deterministic(self):
+        """build_from_clauses should be deterministic given same input."""
+        clauses = [
+            Clause(head=Struct("p", (Atom("a"),)), body=()),
+            Clause(head=Struct("p", (Var(0, "X"),)), body=()),
+            Clause(head=Struct("p", (Int(3),)), body=()),
+        ]
+        
+        idx1 = build_from_clauses(clauses)
+        idx2 = build_from_clauses(clauses)
+        
+        # Both indexes should have identical structure
+        assert idx1.preds.keys() == idx2.preds.keys()
+        p_idx1 = idx1.preds[("p", 1)]
+        p_idx2 = idx2.preds[("p", 1)]
+        
+        assert p_idx1.order == p_idx2.order
+        assert p_idx1.var_ids == p_idx2.var_ids
+        assert p_idx1.int_ids == p_idx2.int_ids
+        assert p_idx1.struct_functor == p_idx2.struct_functor
+
+    def test_bucket_assignment_for_different_types(self):
+        """Clauses should be assigned to correct buckets by first arg type."""
+        clauses = [
+            Clause(head=Struct("p", (Var(0, "X"),)), body=()),  # var
+            Clause(head=Struct("p", (Atom("a"),)), body=()),     # atom
+            Clause(head=Struct("p", (List((), Atom("[]")),)), body=()), # []
+            Clause(head=Struct("p", (List((Atom("h"),), Var(1, "T")),)), body=()), # [h|T]
+            Clause(head=Struct("p", (Int(42),)), body=()),       # int
+            Clause(head=Struct("p", (Struct("f", (Atom("x"),)),)), body=()),  # struct
+        ]
+        
+        idx = build_from_clauses(clauses)
+        p_idx = idx.preds[("p", 1)]
+        
+        assert 0 in p_idx.var_ids
+        assert 1 in p_idx.struct_functor[("a", 0)]
+        assert 2 in p_idx.empty_list_ids
+        assert 3 in p_idx.list_nonempty_ids
+        assert 4 in p_idx.int_ids
+        assert 5 in p_idx.struct_functor[("f", 1)]
+
+
+class TestStaticProgramAssumption:
+    """Tests for static program assumption and guards."""
+
+    def test_index_assumes_static_program(self):
+        """Index should document that it assumes a static program."""
+        clauses = [
+            Clause(head=Struct("p", (Atom("a"),)), body=()),
+        ]
+        
+        idx = build_from_clauses(clauses)
+        # Index should be marked as finalized/static
+        assert hasattr(idx, "finalized")
+        assert idx.finalized is True
+
+    def test_error_if_clauses_added_after_build(self):
+        """Should error/assert if trying to add clauses after index built."""
+        clauses = [
+            Clause(head=Struct("p", (Atom("a"),)), body=()),
+        ]
+        
+        idx = build_from_clauses(clauses)
+        
+        # Attempting to add a clause after build should raise
+        new_clause = Clause(head=Struct("p", (Atom("b"),)), body=())
+        with pytest.raises(AssertionError, match="static program"):
+            idx.add_clause(new_clause)
+
+    def test_rebuild_policy_documented(self):
+        """Index should document rebuild vs assertion policy."""
+        # Stage 2: indexing assumes static programs; dynamic updates must rebuild or assert in dev mode
+        idx = ClauseIndex()
+        # Should have a policy attribute or method
+        assert hasattr(idx, "supports_rebuild") or hasattr(idx, "can_rebuild")
+
+    @pytest.mark.xfail(reason="Float support deferred to future stage")
+    def test_float_bucket_placeholder(self):
+        """Float bucket should exist but be marked as future work."""
+        idx = PredIndex()
+        assert hasattr(idx, "float_ids")
+        # For now, floats would raise NotImplementedError
+        store = Store()
+        from prolog.ast.terms import Float  # May not exist yet
+        head = Struct("p", (Float(3.14),))
+        with pytest.raises(NotImplementedError):
+            analyze_first_arg(head, store)
+
+
+class TestPredicateIsolation:
+    """Tests ensuring predicates never share buckets."""
+
+    def test_predicates_never_share_buckets(self):
+        """Different predicates must never share index buckets."""
+        clauses = [
+            Clause(head=Struct("p", (Atom("shared"),)), body=()),
+            Clause(head=Struct("q", (Atom("shared"),)), body=()),
+        ]
+        
+        idx = build_from_clauses(clauses)
+        
+        p_idx = idx.preds[("p", 1)]
+        q_idx = idx.preds[("q", 1)]
+        
+        # Even with same first arg, buckets are separate
+        assert p_idx.struct_functor[("shared", 0)] == {0}
+        assert q_idx.struct_functor[("shared", 0)] == {0}
+        # But they're different sets
+        assert p_idx.struct_functor is not q_idx.struct_functor
+
+    def test_empty_list_goes_to_special_bucket(self):
+        """Empty list [] must go to empty_list_ids, not struct_functor."""
+        clauses = [
+            Clause(head=Struct("p", (List((), Atom("[]")),)), body=()),  # []
+            Clause(head=Struct("p", (Atom("[]"),)), body=()),      # The atom '[]'
+        ]
+        
+        idx = build_from_clauses(clauses)
+        p_idx = idx.preds[("p", 1)]
+        
+        # First clause (actual empty list) goes to empty_list_ids
+        assert 0 in p_idx.empty_list_ids
+        # Second clause (atom named '[]') also goes to empty_list_ids
+        # because Atom('[]') represents the empty list
+        assert 1 in p_idx.empty_list_ids
+        # Neither should be in struct_functor
+        assert ("[]", 0) not in p_idx.struct_functor
+
+    def test_negative_integers_use_same_bucket(self):
+        """Both positive and negative integers should use int_ids bucket."""
+        clauses = [
+            Clause(head=Struct("p", (Int(3),)), body=()),
+            Clause(head=Struct("p", (Int(-3),)), body=()),
+            Clause(head=Struct("p", (Int(0),)), body=()),
+        ]
+        
+        idx = build_from_clauses(clauses)
+        p_idx = idx.preds[("p", 1)]
+        
+        # All three should be in int_ids
+        assert 0 in p_idx.int_ids
+        assert 1 in p_idx.int_ids
+        assert 2 in p_idx.int_ids
+
+
+class TestAdditionalInvariants:
+    """Additional tests for common regression scenarios."""
+
+    def test_predicate_key_includes_arity(self):
+        """Predicate keys must distinguish by arity (p/0 vs p/1)."""
+        clauses = [
+            Clause(head=Atom("p"), body=()),                                 # p/0
+            Clause(head=Struct("p", (Atom("a"),)), body=()),                 # p/1
+        ]
+        idx = build_from_clauses(clauses)
+        assert ("p", 0) in idx.preds
+        assert ("p", 1) in idx.preds
+        assert idx.preds[("p", 0)].order == [0]
+        assert idx.preds[("p", 1)].order == [0]
+
+    def test_struct_bucket_accumulates_multiple_ids(self):
+        """Struct buckets should hold all IDs with identical principal functor."""
+        clauses = [
+            Clause(head=Struct("p", (Struct("f", (Atom("x"),)),)), body=()),  # id 0
+            Clause(head=Struct("p", (Struct("f", (Atom("y"),)),)), body=()),  # id 1
+            Clause(head=Struct("p", (Var(0,"X"),)), body=()),                 # id 2 (var)
+        ]
+        idx = build_from_clauses(clauses)
+        p = idx.preds[("p", 1)]
+        assert p.struct_functor[("f", 1)] == {0, 1}
+        assert p.order == [0, 1, 2]  # still in source order
+
+    def test_canonical_dot_struct_counts_as_list_nonempty(self):
+        """Canonical '.'/2 structure should be treated as non-empty list."""
+        clauses = [
+            Clause(head=Struct("p", (Struct(".", (Atom("h"), Atom("[]"))),)), body=()),  # [h]
+        ]
+        idx = build_from_clauses(clauses)
+        p = idx.preds[("p", 1)]
+        assert 0 in p.list_nonempty_ids
+        assert ("." , 2) not in p.struct_functor  # not a generic struct bucket
+
+    def test_clause_mapping_populated_for_all_ids(self):
+        """idx.clauses should contain entries for all (pred_key, id) pairs."""
+        clauses = [
+            Clause(head=Struct("p", (Atom("a"),)), body=()),
+            Clause(head=Struct("p", (Var(0,"X"),)), body=()),
+            Clause(head=Struct("q", (Int(1),)), body=()),
+        ]
+        idx = build_from_clauses(clauses)
+        for pred_key, pred_idx in idx.preds.items():
+            for cid in pred_idx.order:
+                assert (pred_key, cid) in idx.clauses
+                assert isinstance(idx.clauses[(pred_key, cid)], Clause)
+
+    def test_interleaved_predicates_have_independent_id_sequences(self):
+        """Interleaved predicates must have independent clause ID sequences."""
+        clauses = [
+            Clause(head=Struct("p", (Atom("a"),)), body=()),  # p id 0
+            Clause(head=Struct("q", (Atom("a"),)), body=()),  # q id 0
+            Clause(head=Struct("p", (Atom("b"),)), body=()),  # p id 1
+            Clause(head=Struct("q", (Atom("b"),)), body=()),  # q id 1
+        ]
+        idx = build_from_clauses(clauses)
+        assert idx.preds[("p", 1)].order == [0, 1]
+        assert idx.preds[("q", 1)].order == [0, 1]
+
+    def test_clauseindex_has_slots_for_memory_efficiency(self):
+        """ClauseIndex should use __slots__ to reduce memory overhead."""
+        idx = ClauseIndex()
+        assert hasattr(idx.__class__, "__slots__")
+        with pytest.raises(AttributeError):
+            _ = idx.__dict__
\ No newline at end of file
