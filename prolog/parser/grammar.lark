// Prolog grammar for Stage 1 (operator-free syntax)
// Issue #9 - Parser Grammar and Basic Terms

// ====================
// Start rules - different entry points for parsing
// ====================

?start: term

term: atom
    | integer
    | variable
    | list
    | structure

atom_only: atom  // For testing atoms specifically

clause: fact | rule

fact: callable DOT

rule: callable COLON_MINUS goal_list DOT

// Callable terms (valid clause heads)
callable: atom
        | structure

goal_list: term (COMMA term)*

query: QUESTION_MINUS goal_list DOT

directive: COLON_MINUS goal_list DOT

// Program is multiple clauses only (Stage 1)
// Queries and directives are parsed separately, not in programs
program: clause+

// ====================
// Terms
// ====================

// Atoms - lowercase start or quoted
atom: ATOM | QUOTED_ATOM

// Integers - including negative (signed literals in Stage 1)
integer: SIGNED_INT

// Variables - uppercase or underscore start
variable: VARIABLE

// Lists
list: LBRACKET RBRACKET                           -> empty_list
    | LBRACKET term_list RBRACKET                 -> proper_list
    | LBRACKET term_list PIPE term RBRACKET        -> list_with_tail

term_list: term (COMMA term)*

// Structures (compound terms)
structure: atom LPAREN term_list RPAREN
// Note: foo/2 predicate indicators removed from general terms
// Will add pred_indicator rule if/when needed in specific contexts

// ====================
// Lexer rules (terminals)
// ====================

// Keywords must come before ATOM to get priority
// Word operators (must be recognized as separate tokens before ATOM)
MOD: "mod"
IS: "is"
IN: "in"

// Atoms (after keywords)
ATOM: /[a-z][a-zA-Z0-9_]*/
    | "!"            // cut as atom (Stage 1 needs this in goal lists)

// Quoted atoms with escape sequences
QUOTED_ATOM: "'" QUOTED_CHAR* "'"
QUOTED_CHAR: /[^'\\]/
           | "\\" /[\\nt']/    // Escapes: \\, \n, \t, \'
           | "''"               // Doubled quote (future)

// Integers (signed literals for Stage 1)
SIGNED_INT: /-?\d+/

// Variables (including anonymous _)
VARIABLE: /[A-Z_][a-zA-Z0-9_]*/

// ====================
// Operator tokens (Stage 1.5)
// ====================
// These are recognized as tokens but have no precedence in the grammar.
// The reader will transform them to canonical forms using the operator table.
// IMPORTANT: Longest match takes priority (Lark's default behavior)
//
// ORDER MATTERS for longest-match:
//   - "=\\=" must come before "=" to match the full operator
//   - "@=<" must come before "@<" 
//   - "\\==" must come before "\\="
//   - ">=" must come before ">"
//   - "=<" must come before "="
//   - "//" must come before "/"
// This ensures e.g. "X=\\=Y" tokenizes as [X, =\\=, Y] not [X, =, \\=, Y]

// Multi-character operators (must come before single-char to ensure longest match)
ARROW: "->"
DOUBLE_SLASH: "//"
EQ_COLON_EQ: "=:="
EQ_BACKSLASH_EQ: "=\\="
BACKSLASH_EQ: "\\="
BACKSLASH_EQEQ: "\\=="
AT_LT: "@<"
AT_GT: "@>"
AT_EQ_LT: "@=<"
AT_GT_EQ: "@>="
EQ_LT: "=<"
GT_EQ: ">="
DOUBLE_EQ: "=="
DOUBLE_STAR: "**"
BACKSLASH_PLUS: "\\+"

// CLP(FD) operators
DOT_DOT: ".."
HASH_EQ: "#="
HASH_BACKSLASH_EQ: "#\\="
HASH_LT: "#<"
HASH_GT: "#>"
HASH_EQ_LT: "#=<"
HASH_GT_EQ: "#>="

// Single-character operators
COMMA: ","
SEMICOLON: ";"
EQUALS: "="
LT: "<"
GT: ">"
PLUS: "+"
MINUS: "-"
STAR: "*"
SLASH: "/"


// Parentheses (needed for operator expressions)
LPAREN: "("
RPAREN: ")"
LBRACKET: "["
RBRACKET: "]"

// Other punctuation
PIPE: "|"
COLON_MINUS: ":-"
QUESTION_MINUS: "?-"

// Single character last (DOT must be after DOT_DOT!)
DOT: "."

// Comments
COMMENT: /%.*/
BLOCK_COMMENT: /\/\*(.|\n)*?\*\//  // Handles multiline block comments

// Whitespace - ignored
%ignore /\s+/
%ignore COMMENT
%ignore BLOCK_COMMENT

// ====================
// Operator precedence (none in Stage 1)
// ====================
// All operators are written as functors in Stage 1
// e.g., +(1,2) instead of 1+2
// Stage 1.5 will add operator support via reader